<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot自动配置原理</title>
      <link href="/2022/03/29/weifuwu01springbootzidongpeizhiyuanli/"/>
      <url>/2022/03/29/weifuwu01springbootzidongpeizhiyuanli/</url>
      
        <content type="html"><![CDATA[<h4 id="1、SpringBoot的自动配置原理"><a href="#1、SpringBoot的自动配置原理" class="headerlink" title="1、SpringBoot的自动配置原理"></a>1、SpringBoot的自动配置原理</h4><h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>不知道大家第一次搭SpringBoot环境的时候，有没有觉得非常简单。无须各种的配置文件，无须各种繁杂的pom坐标， 一个main方法，就能run起来了。与其他框架整合也贼方便，使用EnableXXXXX注解就可以搞起来了！ 所以今天来讲讲SpringBoot是如何实现自动配置的~</p><h5 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h5><p><strong>自动配置流程图</strong></p><p><a href="https://www.processon.com/view/link/5fc0abf67d9c082f447ce49b">https://www.processon.com/view/link/5fc0abf67d9c082f447ce49b</a></p><p><strong>源码的话就先从启动类开始入手：</strong></p><p><strong>@SpringBootApplication</strong></p><p>Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot 需要运行这个类的main方法来启动SpringBoot应用；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = {@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注解说明：</p><ul><li><p><code>@Target(ElementType.TYPE)</code> 设置当前注解可以标记在哪  </p></li><li><blockquote><p><code>@Retention(RetentionPolicy.RUNTIME)</code> 注解存在生命周期，默认CLASS，加载到jvm被遗弃</p><p><code>RetentionPolicy.RUNTIME</code> 会被jvm加载</p></blockquote></li><li><p><code>@Documented</code> java doc 会生成注解信息</p></li><li><p><code>@Inherited</code> 是否会被继承</p></li><li><blockquote><p><code>@SpringBootConfiguration</code> 标注在某个类上，表示这是一个Spring Boot的配置类</p><p><code>@Configuration</code> 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component</p></blockquote></li><li><p><code>@EnableAutoConfiguration</code> SpringBoot开启自动配置，会帮我们自动去加载 自动配置类</p></li><li><blockquote><p><code>@ComponentScan</code> 相当于在spring.xml 配置中<a href="context:comonent-scan">context:comonent-scan</a> 指定spring底层会自动扫描当前配置类所有在的包  </p><p><code>TypeExcludeFilter</code> springboot对外提供的扩展类， 可以供我们去按照我们的方式进行排除</p><p><code>AutoConfigurationExcludeFilter</code> 排除所有配置类并且是自动配置类中里面的其中一个</p></blockquote></li></ul><p> <strong>@EnableAutoConfiguration</strong></p><p>这个注解里面，最主要的就是@EnableAutoConfiguration，这么直白的名字，一看就知道它要开启自动配置，SpringBoot要开始骚了，于是默默进去@EnableAutoConfiguration的源码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration {// 略}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>@AutoConfigurationPackage</strong></p><p>将当前配置类所在包保存在BasePackages的Bean中。供Spring内部使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import(AutoConfigurationPackages.Registrar.class) // 保存扫描路径， 提供给spring‐data‐jpa 需要扫描 @Ent itypublic @interface AutoConfigurationPackage {// 就是注册了一个保存当前配置类所在包的一个Bean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>@Import(EnableAutoConfigurationImportSelector.class) 关键点！</strong></p><p>可以看到，在**@EnableAutoConfiguration<strong>注解内使用到了</strong>@import<strong>注解来完成导入配置的功能，而</strong>EnableAutoConfigurationImportSelector<strong>实现了</strong>DeferredImportSelectorSpring<strong>内部在解析@Import注解时会调用</strong>getAutoConfigurationEntry**方法，这块属于Spring的源码，有点复杂，我们先不管它是怎么调用的。 下面是2.3.5.RELEASE</p><p>实现源码：</p><p>getAutoConfigurationEntry方法进行扫描具有META-INF/spring.factories文件的jar包。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {  if (!isEnabled(annotationMetadata)) {  return EMPTY_ENTRY;  }AnnotationAttributes attributes = getAttributes(annotationMetadata);  // 从META‐INF/spring.factories中获得候选的自动配置类  List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);  // 排重  configurations = removeDuplicates(configurations);//根据EnableAutoConfiguration注解中属性，获取不需要自动装配的类名单Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);// 根据:@EnableAutoConfiguration.exclude// @EnableAutoConfiguration.excludeName  // spring.autoconfigure.exclude 进行排除  checkExcludedClasses(configurations, exclusions);  // exclusions 也排除  configurations.removeAll(exclusions);  // 通过读取spring.factories 中的OnBeanCondition\OnClassCondition\OnWebApplicationCondition进行过滤  configurations = getConfigurationClassFilter().filter(configurations);  // 这个方法是调用实现了AutoConfigurationImportListener 的bean.. 分别把候选的配置名单，和排除的配置名单传进去做扩展  fireAutoConfigurationImportEvents(configurations, exclusions);  return new AutoConfigurationEntry(configurations, exclusions);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何一个springboot应用，都会引入spring-boot-autoconfigure，而spring.factories文件就在该包下面。spring.factories文件是 Key=Value形式，多个Value时使用,隔开，该文件中定义了关于初始化，监听器等信息，而真正使自动配置生效的key是 org.springframework.boot.autoconfigure.EnableAutoConfiguration，如下所示： 等同于</p><p>@Import({</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\...省略org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>})</p><p>每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 所有自动配置类表 </p><ul><li>每一个自动配置类进行自动配置功能；</li></ul><p>后续： @EnableAutoConfiguration注解通过@SpringBootApplication被间接的标记在了Spring Boot的启动类上。在 SpringApplication.run(…)的内部就会执行selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的 class，然后将所有自动配置类加载到Spring容器中</p><ul><li>以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties(ServerProperties.class)@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)@ConditionalOnClass(CharacterEncodingFilter.class)@ConditionalOnProperty(prefix = "server.servlet.encoding", value = "enabled", matchIfMissing = true)public class HttpEncodingAutoConfiguration {private final Encoding properties;public HttpEncodingAutoConfiguration(ServerProperties properties) {this.properties = properties.getServlet().getEncoding();}@Bean@ConditionalOnMissingBeanpublic CharacterEncodingFilter characterEncodingFilter() {CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();filter.setEncoding(this.properties.getCharset().name());filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST));filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE));return filter;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>@Configuration(proxyBeanMethods = false)</strong></p><ul><li>标记了@Configuration Spring底层会给配置创建cglib动态代理。 作用：就是防止每次调用本类的Bean方法而重新创建对 象，Bean是默认单例的</li></ul><p><strong>@EnableConfigurationProperties(ServerProperties.class)</strong></p><ul><li>启用可以在配置类设置的属性 对应的类</li></ul><p><strong>@xxxConditional</strong></p><ul><li>根据当前不同的条件判断，决定这个配置类是否生效</li></ul><p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th align="left">@Conditional扩展注解作用</th><th>（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td align="left">@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td align="left">@ConditionalOnBean</td><td>容器中存在指定Bean</td></tr><tr><td align="left">@ConditionalOnMissingBean</td><td>容器中不存在指定Bean</td></tr><tr><td align="left">@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td align="left">@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td align="left">@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td align="left">@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td align="left">@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td align="left">@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td align="left">@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td align="left">@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td align="left">@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p>我们怎么知道哪些自动配置类生效； 我们可以通过设置配置文件中：启用 <strong>debug=true</strong>属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</p><pre class="line-numbers language-tex" data-language="tex"><code class="language-tex">============================CONDITIONS EVALUATION REPORT============================Positive matches: ‐‐‐**表示自动配置类启用的**-----------------AopAutoConfiguration matched:      - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition)...省略...Negative matches: ---**没有匹配成功的自动配置类**ActiveMQAutoConfiguration:      Did not match:         - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition)-----------------...省略...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我么就以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例说明自动配置原理； 该注解如下：</p><p><img src="http://feng.mynatapp.cc/blog/20220330134658.png"></p><ul><li>@Configuration：表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件。</li><li>@ConditionalOnWebApplication：Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效。</li><li>@ConditionalOnClass：判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器。</li><li>@ConditionalOnProperty：判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的；即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的。</li><li>@EnableConfigurationProperties({ServerProperties.class})：将配置文件中对应的值和 ServerProperties绑定起来； 并把 ServerProperties加入到 IOC 容器中。并注册ConfigurationPropertiesBindingPostProcessor用于将@ConfigurationProperties的类和配置进行绑定</li></ul><p><strong>ServerProperties</strong></p><p><img src="http://feng.mynatapp.cc/blog/20220330135024.png"></p><p>ServerProperties通过 @ConfigurationProperties 注解将配置文件与自身属性绑定。</p><p>对于@ConfigurationProperties注解小伙伴们应该知道吧，我们如何获取全局配置文件的属性中用到，它的作用就是把全局配置文件中的值绑定到实体类JavaBean上面（将配置文件中的值与ServerProperites绑定起来），而@EnableConfigurationProperties主要是把以绑定值JavaBean加入到spring容器中。 到这里，小伙伴们应该明白</p><p>我们在application.properties 声明spring.application.name 是通过@ConfigurationProperties注解，绑定到对应的XxxxProperties配 置实体类上，然后再通过@EnableConfigurationProperties注解导入到Spring容器中.</p><p>所以只有知道了自动配置的原理及源码 才能灵活的配置SpringBoot</p><p><img src="http://feng.mynatapp.cc/blog/20220330135322.png"></p><h4 id="2、自定义starter"><a href="#2、自定义starter" class="headerlink" title="2、自定义starter"></a>2、自定义starter</h4><h5 id="一、简介-1"><a href="#一、简介-1" class="headerlink" title="一、简介"></a>一、简介</h5><p>SpringBoot 最强大的功能就是把我们常用的场景抽取成了一个个starter（场景启动器），我们通过引入springboot 为我提供的这些场景启动器，我们再进行少量的配置就能使用相应的功能。即使是这样，springboot也不能囊括我们所有的使用场景，往往我们需要自定义starter，来简化我们对springboot的使用。</p><h5 id="二、如何自定义starter"><a href="#二、如何自定义starter" class="headerlink" title="二、如何自定义starter"></a>二、如何自定义starter</h5><h6 id="1-实例"><a href="#1-实例" class="headerlink" title="1.实例"></a>1.实例</h6><p><strong>如何编写自动配置 ？</strong></p><p>我们参照@WebMvcAutoConfiguration为例，我们看看们需要准备哪些东西，下面是WebMvcAutoConfiguration的部分代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,ValidationAutoConfiguration.class })public class WebMvcAutoConfiguration {<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以抽取到我们自定义starter时同样需要的一些配置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration //指定这个类是一个配置类@ConditionalOnXXX //指定条件成立的情况下自动配置类生效@AutoConfigureOrder //指定自动配置类的顺序@Bean //向容器中添加组件@ConfigurationProperties //结合相关xxxProperties来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载需要将自动配置类，配置在META‐INF/spring.factories中org.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>模式</strong></p><p>我们参照 spring-boot-starter 我们发现其中没有代码：</p><p><img src="http://feng.mynatapp.cc/blog/20220330140554.png"></p><p>我们在看它的pom中的依赖中有个 springboot-starter</p><p><img src="http://feng.mynatapp.cc/blog/20220330141159.png"></p><p>我们再看看 spring-boot-starter 有个 spring-boot-autoconfigure</p><p><img src="http://feng.mynatapp.cc/blog/20220330141245.png"></p><p>关于web的一些自动配置都写在了这里 ，所以我们有总结：</p><ul><li>启动器（starter）是一个空的jar文件，仅仅提供辅助性依赖管理，这些依赖可能用于自动装配或其他类库。</li><li>需要专门写一个类似spring-boot-autoconfigure的配置模块</li><li>用的时候只需要引入启动器starter，就可以使用自动配置了</li></ul><p><strong>命名规范</strong></p><p>官方命名空间 </p><ul><li>前缀：spring-boot-starter</li><li>模式：spring-boot-starter-模块名 </li><li>举例：spring-boot-starter-web、spring-boot-starter-jdbc </li></ul><p>自定义命名空间 </p><ul><li>后缀：-spring-boot-starter </li><li>模式：模块-spring-boot-starter </li><li>举例：mybatis-spring-boot-starter</li></ul><h5 id="三、自定义starter实例"><a href="#三、自定义starter实例" class="headerlink" title="三、自定义starter实例"></a>三、自定义starter实例</h5><p>我们需要先创建一个父maven项目:springboot_custome_starter 两个Module: demo-spring-boot-starter 和 demo-spring-boot-starter-autoconfigurer</p><p><strong>1.springboot_custome_starter</strong></p><p><strong>pom.xml</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">&gt;</span></span>demo-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">&gt;</span></span>demo-spring-boot-starter-autoconfigurer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.3.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.feng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springboot_custome_starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.demo-spring-boot-starter</strong></p><p><strong>pom.xml</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springboot_custome_starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.feng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>demo-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>        启动器（starter）是一个空的jar文件，        仅仅提供辅助性依赖管理，        这些依赖需要自动装配或其他类库。    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 引入autoconfigure --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.feng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>demo-spring-boot-starter-autoconfigurer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--如果当前starter 还需要其他的类库就在这里引用--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.demo-spring-boot-starter-autoconfigurer</strong></p><p><strong>pom.xml</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springboot_custome_starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.feng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>demo-spring-boot-starter-autoconfigurer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-configuration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HelloProperties</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.starter;import org.springframework.boot.context.properties.ConfigurationProperties;/** * &lt;p&gt; * HelloProperties * &lt;/p&gt; * * @author pyf 2022-03-30 */@ConfigurationProperties("demo.hello")public class HelloProperties {    private String name;    public void setName(String name) {        this.name = name;    }    public String getName() {        return name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>IndexController</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.starter;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * &lt;p&gt; * IndexController * &lt;/p&gt; * * @author pyf 2022-03-30 */@RestControllerpublic class IndexController {    HelloProperties helloProperties;    public IndexController(HelloProperties helloProperties) {        this.helloProperties = helloProperties;    }    @GetMapping("/")    public String index() {        return helloProperties.getName();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HelloAutoConfitguration</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * &lt;p&gt; * HelloAutoConfiguration * &lt;/p&gt; * * @author pyf 2022-03-30 */@Configuration@ConditionalOnProperty(value = "demo.hello.name")@EnableConfigurationProperties(HelloProperties.class)public class HelloAutoConfiguration {    @Autowired    HelloProperties helloProperties;    @Bean    public IndexController indexController() {        return new IndexController(helloProperties);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>spring.factories</strong></p><img src="http://feng.mynatapp.cc/blog/20220330170814.png" style="zoom:50%;"><p><img src="http://feng.mynatapp.cc/blog/20220330170845.png"></p><p>到这儿，我们的配置自定义的starter就写完了 ，我们demo-spring-boot-starter-autoconfigurer、demo-spring-boot-starter 安装成本地jar包。</p><h5 id="三、测试自定义starter"><a href="#三、测试自定义starter" class="headerlink" title="三、测试自定义starter"></a>三、测试自定义starter</h5><p>引入依赖，启动Application</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.feng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>demo-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>浏览<a href="http://localhost:8080/">http://localhost:8080/</a>  报错</p><p><img src="http://feng.mynatapp.cc/blog/20220330171219.png"></p><p>application.yml 添加</p><pre class="line-numbers language-tex" data-language="tex"><code class="language-tex">#debug=trueserver:  port: 8080demo:  hello:    name: 自动配置demo演示成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次访问 <a href="http://localhost:8080/">http://localhost:8080/</a> </p><p><img src="http://feng.mynatapp.cc/blog/20220330174004.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>领域模型</title>
      <link href="/2022/03/22/lingyumoxinglingyumoxingtx/"/>
      <url>/2022/03/22/lingyumoxinglingyumoxingtx/</url>
      
        <content type="html"><![CDATA[<h1 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h1><h3 id="领域模型设计系统的过程步骤"><a href="#领域模型设计系统的过程步骤" class="headerlink" title="领域模型设计系统的过程步骤"></a>领域模型设计系统的过程步骤</h3><ol><li>事件风暴 + 领域分析：用例分析、场景分析、用户旅程</li><li>操作、命令、事件 –&gt; 实体 与 聚合</li><li>领域模型 –&gt; 代码模型</li><li>代码落地</li></ol><h3 id="域的分类"><a href="#域的分类" class="headerlink" title="域的分类"></a>域的分类</h3><ul><li>通用域：权限、认证，通常可以买到</li><li>核心域：公司核心竞争力 - 会随着公司战略、业务模式等不同，核心域会不同</li><li>支撑域：根据公司业务个性化定制</li></ul><h3 id="上下文界限"><a href="#上下文界限" class="headerlink" title="上下文界限"></a>上下文界限</h3><p>上下文界限例子，四个阶段中保单的四个领域实体，</p><ol><li>客户投保时，业务人员记录投保信息，系统对应有投保单实体对象</li><li>缴费完成后，业务人员将投保单转为<strong>保单</strong>，系统对应有保单实体对象，保单实体与投保单实体关联</li><li>如客户需要修改保单信息，保单变为批单，系统对应有批单实体对象，批单实体与保单实体关联</li><li>如果客户发生理赔，生成赔案，系统对应有报案实体对象，报案实体对象与保单或者批单实体关联</li></ol><h1 id="实体与值对象"><a href="#实体与值对象" class="headerlink" title="实体与值对象"></a>实体与值对象</h1><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul><li>业务形态<ul><li>根据操作、命令、事件找到业务实体</li><li>根据业务规则进行聚类</li></ul></li><li>代码形态<ul><li>完成自身的业务逻辑（通常是充血模型）</li><li>*跨多个实体的领域逻辑，在Service中完成</li></ul></li><li>运行形态<ul><li>运行时，通过ID作为唯一标识</li><li>通过ID判断相等</li></ul></li><li>数据库形态<ul><li>优先产生领域模型，再考虑计数据库的持久化</li><li>多数情况下是与实体一对一的</li><li>但是某些情况下也可以是一对多，多对一</li><li>甚至是内存暂存状态，也就是一对0。</li></ul></li></ul><h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h3><ul><li>业务形态<ul><li>一种属性集合</li><li>最典型的值对象就是数据字典</li></ul></li><li>代码形态<ul><li>基本不包含业务逻辑</li><li>只有数据初始化操作、有限的不涉及修改数据的业务</li></ul></li><li>运行形态<ul><li>初始化构造</li><li>在实体中替换值对象（创建后不能修改，只能用另外一个值对象替换）</li><li>通过属性值判断相等</li></ul></li><li>数据库形态<ul><li>可以单独成表</li><li>也可以嵌入在实体的表中</li></ul></li></ul><h3 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h3><p>值对象是对实体的描述。在不同的领域甚至是子域里面，实体和值对象是可以互换的，如</p><ul><li>开立医嘱的业务中，医生作为被医嘱实体引用的描述，是一个值对象。</li><li>在用户信息修改的业务中，医生就是存在唯一ID的实体了</li></ul><h1 id="聚合和聚合根"><a href="#聚合和聚合根" class="headerlink" title="聚合和聚合根"></a>聚合和聚合根</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>聚合根是一个实体，相当于单个聚合的管理者</li><li>聚合是指负责<strong>单一业务职责</strong>、<strong>高聚合</strong>的一系列实体和值对象</li><li>聚合是通过充血模型实现的</li><li>聚合存在上下文边界，边界之间是松耦合的</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>一个聚合诞生的完整过程：</p><ol><li>采用事件风暴，根据业务行为，梳理出在投保过程中发生这些行为的所有的实体和值对象，比如投保单、标的、客户、被保人等等。</li><li>从众多实体中选出适合作为对象管理者的聚合根。判断一个实体是否是聚合根，可以结合场景分析：<ul><li>是否有独立的什么周期（实体 / 值对象）</li><li>是否有全局唯一ID（实体 / 值对象）</li><li>是否可以创建或修改其他对象（实体 / 值对象）</li><li>是否有专门的模块来管理这个实体（实体 / 聚合根）</li><li>本例中两个聚合根分别是 <strong>投保单</strong> 和 <strong>客户</strong></li></ul></li><li>根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值对象。构建出一个包含聚合根（唯一）、多个实体和值对象的对象集合，这个集合就是聚合。</li><li>在聚合内根据聚合根、实体和值对象的依赖关系，理出对象的引用和依赖模型。在本例中，投保人和被保人的数据，是通过关联客户ID从客户聚合中获取的，在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户聚合的数据发生了变更，也不会影响投保单的值对象数据。例子中，投保聚合里投保单聚合根引用了报价单实体，报价单实体则引用了报价规则实体。</li><li>多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。</li></ol><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>聚合在一致性边界内建模真正的不变条件</li><li>设计小聚合（聚合不宜包含太多的实体）</li><li>通过ID引用其他聚合</li><li>聚合内的数据，在边界之外使用最终一致性</li><li>通过应用层实现跨聚合的服务调用（领域层内，不应该进行跨聚合之间的调用）</li></ul><h1 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h1><p>CDSS系统中暂时没有业务步骤，也不需要领域事件</p><ol><li>事件构建和发布</li><li>事件数据持久化</li><li>事件总线</li><li>消息中间件</li><li>事件接收和处理</li></ol><p>事件基类：</p><ul><li>ID: String</li><li>createTime: Date</li><li>eventType: String</li><li>eventSource: String</li><li>BusinessData: T</li></ul><h1 id="领域模型架构"><a href="#领域模型架构" class="headerlink" title="领域模型架构"></a>领域模型架构</h1><h3 id="传统三层架构"><a href="#传统三层架构" class="headerlink" title="传统三层架构"></a>传统三层架构</h3><ul><li>业务接口层<ul><li>Module - API</li></ul></li><li>业务逻辑层<ul><li>VO</li><li>Service</li></ul></li><li>数据访问层<ul><li>PO</li><li>MapperXML</li><li>Dao</li></ul></li></ul><h3 id="★DDD分层模型"><a href="#★DDD分层模型" class="headerlink" title="★DDD分层模型"></a>★DDD分层模型</h3><ul><li>用户接口层<ul><li>API</li><li>DTO</li></ul></li><li>应用层（应对快速的业务变化）<ul><li>Application Service</li></ul></li><li>领域层（核心业务能力）<ul><li>Aggregate<ul><li>Domain Service</li><li>Entity</li><li>Value Object</li></ul></li><li>MapperXML</li><li>Repository</li></ul></li><li>基础层<ul><li>Repository AOP</li><li>网关</li><li>第三方库</li><li>文件</li><li>其他</li></ul></li></ul><p><img src="http://feng.mynatapp.cc/blog/image-20220509175728519.png" alt="image-20220509175728519"></p><h3 id="★整洁架构"><a href="#★整洁架构" class="headerlink" title="★整洁架构"></a>★整洁架构</h3><p><img src="http://feng.mynatapp.cc/blog/image-20220509175757890.png" alt="image-20220509175757890"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型</title>
      <link href="/2022/03/22/xingnengdiaoyou02jvmneicunmoxingshendupouxiyuyouhua/"/>
      <url>/2022/03/22/xingnengdiaoyou02jvmneicunmoxingshendupouxiyuyouhua/</url>
      
        <content type="html"><![CDATA[<h4 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h4><p><img src="http://feng.mynatapp.cc/blog/20220329154246.png"></p><h4 id="Java语言的跨平台特性"><a href="#Java语言的跨平台特性" class="headerlink" title="Java语言的跨平台特性"></a>Java语言的跨平台特性</h4><img src="http://feng.mynatapp.cc/blog/20220329154313.png" style="zoom:50%;"><h4 id="JVM整体结构及内存模型"><a href="#JVM整体结构及内存模型" class="headerlink" title="JVM整体结构及内存模型"></a>JVM整体结构及内存模型</h4><p><img src="http://feng.mynatapp.cc/blog/20220329154345.png"></p><h4 id="二、JVM内存参数设置"><a href="#二、JVM内存参数设置" class="headerlink" title="二、JVM内存参数设置"></a>二、JVM内存参数设置</h4><img src="http://feng.mynatapp.cc/blog/20220329154411.png" style="zoom:50%;"><p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：</p><pre class="line-numbers language-none"><code class="language-none">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eurek a‐server.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N</p><p><strong>-XX：MaxMetaspaceSize</strong>： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。</p><p><strong>-XX：MetaspaceSize</strong>： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发 full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超 过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的**-XX:PermSize<strong>参数意思不一样，</strong>XX:PermSize**代表永久代的初始容量。</p><p>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生 了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大， 对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。</p><p><strong>StackOverflowError</strong>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.learn.jvm.source02;/** * &lt;p&gt; * JVM设置 ‐Xss128k(默认1M) * &lt;/p&gt; * * @author pyf 2022-03-21 */public class StackOverflowTest {    static int count = 0;    static void redo() {        count++;        redo();    }    public static void main(String[] args) {        try {            redo();        } catch (Throwable t) {            t.printStackTrace();            System.out.println(count);        }    }}运行结果：java.lang.StackOverflowErrorat com.learn.jvm.StackOverflowTest.redo(StackOverflowTest.java:12)   at com.learn.jvm.StackOverflowTest.redo(StackOverflowTest.java:13)   at com.learn.jvm.StackOverflowTest.redo(StackOverflowTest.java:13)   ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结论：</strong></p><p>-Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多</p><p><strong>JVM内存参数大小该如何设置？</strong></p><p>JVM参数大小设置并没有固定标准，需要根据实际项目情况分析，给大家举个例子</p><p><strong>日均百万级订单交易系统如何设置JVM参数</strong></p><p><img src="http://feng.mynatapp.cc/blog/20220329154624.png"></p><p><img src="http://feng.mynatapp.cc/blog/20220329154641.png"></p><p><strong>结论：通过上面这些内容介绍，大家应该对JVM优化有些概念了，就是尽可能让对象都在新生代里分配和回收，尽量别 让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM指令手册</title>
      <link href="/2022/03/22/xingnengdiaoyou00jvmzhilingshouce/"/>
      <url>/2022/03/22/xingnengdiaoyou00jvmzhilingshouce/</url>
      
        <content type="html"><![CDATA[<h4 id="栈和局部变量操作"><a href="#栈和局部变量操作" class="headerlink" title="栈和局部变量操作"></a>栈和局部变量操作</h4><h5 id="将常量压入栈的指令"><a href="#将常量压入栈的指令" class="headerlink" title="将常量压入栈的指令"></a>将常量压入栈的指令</h5><pre class="line-numbers language-none"><code class="language-none">aconst_null 将null对象引用压入栈 iconst_m1 将int类型常量-1压入栈 iconst_0 将int类型常量0压入栈 iconst_1 将int类型常量1压入操作数栈 iconst_2 将int类型常量2压入栈 iconst_3 将int类型常量3压入栈 iconst_4 将int类型常量4压入栈 iconst_5 将int类型常量5压入栈 lconst_0 将long类型常量0压入栈 lconst_1 将long类型常量1压入栈 fconst_0 将float类型常量0压入栈 fconst_1 将float类型常量1压入栈 dconst_0 将double类型常量0压入栈 dconst_1 将double类型常量1压入栈 bipush 将一个8位带符号整数压入栈 sipush 将16位带符号整数压入栈 ldc 把常量池中的项压入栈 ldc_w 把常量池中的项压入栈（使用宽索引） ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="从栈中的局部变量中装载值的指令"><a href="#从栈中的局部变量中装载值的指令" class="headerlink" title="从栈中的局部变量中装载值的指令"></a>从栈中的局部变量中装载值的指令</h5><pre class="line-numbers language-none"><code class="language-none">iload 从局部变量中装载int类型值 lload 从局部变量中装载long类型值 fload 从局部变量中装载float类型值 dload 从局部变量中装载double类型值 aload 从局部变量中装载引用类型值（refernce） iload_0 从局部变量0中装载int类型值 iload_1 从局部变量1中装载int类型值 iload_2 从局部变量2中装载int类型值 iload_3 从局部变量3中装载int类型值 lload_0 从局部变量0中装载long类型值 lload_1 从局部变量1中装载long类型值 lload_2 从局部变量2中装载long类型值 lload_3 从局部变量3中装载long类型值 fload_0 从局部变量0中装载float类型值 fload_1 从局部变量1中装载float类型值 fload_2 从局部变量2中装载float类型值 fload_3 从局部变量3中装载float类型值 dload_0 从局部变量0中装载double类型值 dload_1 从局部变量1中装载double类型值 dload_2 从局部变量2中装载double类型值 dload_3 从局部变量3中装载double类型值 aload_0 从局部变量0中装载引用类型值 aload_1 从局部变量1中装载引用类型值 aload_2 从局部变量2中装载引用类型值 aload_3 从局部变量3中装载引用类型值 iaload 从数组中装载int类型值 laload 从数组中装载long类型值 faload 从数组中装载float类型值 daload 从数组中装载double类型值 aaload 从数组中装载引用类型值 baload 从数组中装载byte类型或boolean类型值 caload 从数组中装载char类型值 saload 从数组中装载short类型值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="将栈中的值存入局部变量的指令"><a href="#将栈中的值存入局部变量的指令" class="headerlink" title="将栈中的值存入局部变量的指令"></a>将栈中的值存入局部变量的指令</h5><pre class="line-numbers language-none"><code class="language-none">istore 将int类型值存入局部变量 lstore 将long类型值存入局部变量 fstore 将float类型值存入局部变量 dstore 将double类型值存入局部变量 astore 将将引用类型或returnAddress类型值存入局部变量 istore_0 将int类型值存入局部变量0 istore_1 将int类型值存入局部变量1 istore_2 将int类型值存入局部变量2 istore_3 将int类型值存入局部变量3 lstore_0 将long类型值存入局部变量0 lstore_1 将long类型值存入局部变量1 lstore_2 将long类型值存入局部变量2 lstore_3 将long类型值存入局部变量3 fstore_0 将float类型值存入局部变量0 fstore_1 将float类型值存入局部变量1 fstore_2 将float类型值存入局部变量2 fstore_3 将float类型值存入局部变量3 dstore_0 将double类型值存入局部变量0 dstore_1 将double类型值存入局部变量1 dstore_2 将double类型值存入局部变量2 dstore_3 将double类型值存入局部变量3 astore_0 将引用类型或returnAddress类型值存入局部变量0 astore_1 将引用类型或returnAddress类型值存入局部变量1 astore_2 将引用类型或returnAddress类型值存入局部变量2 astore_3 将引用类型或returnAddress类型值存入局部变量3 iastore 将int类型值存入数组中 lastore 将long类型值存入数组中 fastore 将float类型值存入数组中 dastore 将double类型值存入数组中 aastore 将引用类型值存入数组中 bastore 将byte类型或者boolean类型值存入数组中 castore 将char类型值存入数组中 sastore 将short类型值存入数组中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h5><pre class="line-numbers language-none"><code class="language-none">wide 使用附加字节扩展局部变量索引<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="通用-无类型）栈操作"><a href="#通用-无类型）栈操作" class="headerlink" title="通用(无类型）栈操作"></a>通用(无类型）栈操作</h5><pre class="line-numbers language-none"><code class="language-none">nop 不做任何操作 pop 弹出栈顶端一个字长的内容 pop2 弹出栈顶端两个字长的内容 dup 复制栈顶部一个字长内容 dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入 栈 dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入 栈 dup2 复制栈顶部两个字长内容 dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入 栈 dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入 栈 swap 交换栈顶部两个字长内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><pre class="line-numbers language-none"><code class="language-none">i2l 把int类型的数据转化为long类型 i2f 把int类型的数据转化为float类型 i2d 把int类型的数据转化为double类型 l2i 把long类型的数据转化为int类型 l2f 把long类型的数据转化为float类型 l2d 把long类型的数据转化为double类型 f2i 把float类型的数据转化为int类型 f2l 把float类型的数据转化为long类型 f2d 把float类型的数据转化为double类型 d2i 把double类型的数据转化为int类型 d2l 把double类型的数据转化为long类型 d2f 把double类型的数据转化为float类型 i2b 把int类型的数据转化为byte类型 i2c 把int类型的数据转化为char类型 i2s 把int类型的数据转化为short类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h5><pre class="line-numbers language-none"><code class="language-none">iadd 执行int类型的加法 ladd 执行long类型的加法 isub 执行int类型的减法 lsub 执行long类型的减法 imul 执行int类型的乘法 lmul 执行long类型的乘法 idiv 执行int类型的除法 ldiv 执行long类型的除法 irem 计算int类型除法的余数 lrem 计算long类型除法的余数 ineg 对一个int类型值进行取反操作 lneg 对一个long类型值进行取反操作 iinc 把一个常量值加到一个int类型的局部变量上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><h5 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h5><pre class="line-numbers language-none"><code class="language-none">ishl 执行int类型的向左移位操作 lshl 执行long类型的向左移位操作 ishr 执行int类型的向右移位操作 lshr 执行long类型的向右移位操作 iushr 执行int类型的向右逻辑移位操作 lushr 执行long类型的向右逻辑移位操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h5><pre class="line-numbers language-none"><code class="language-none">iand 对int类型值进行“逻辑与”操作 land 对long类型值进行“逻辑与”操作 ior 对int类型值进行“逻辑或”操作 lor 对long类型值进行“逻辑或”操作 ixor 对int类型值进行“逻辑异或”操作 lxor 对long类型值进行“逻辑异或”操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h5><pre class="line-numbers language-none"><code class="language-none">fadd 执行float类型的加法 dadd 执行double类型的加法 fsub 执行float类型的减法 dsub 执行double类型的减法 fmul 执行float类型的乘法 dmul 执行double类型的乘法 fdiv 执行float类型的除法 ddiv 执行double类型的除法 frem 计算float类型除法的余数 drem 计算double类型除法的余数 fneg 将一个float类型的数值取反 dneg 将一个double类型的数值取反<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h4><h5 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h5><pre class="line-numbers language-none"><code class="language-none">new 创建一个新对象 checkcast 确定对象为所给定的类型 getfield 从对象中获取字段 putfield 设置对象中字段的值 getstatic 从类中获取静态字段 putstatic 设置类中静态字段的值 instanceof 判断对象是否为给定的类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h5><pre class="line-numbers language-none"><code class="language-none">newarray 分配数据成员类型为基本上数据类型的新数组 anewarray 分配数据成员类型为引用类型的新数组 arraylength 获取数组长度 multianewarray 分配新的多维数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><h5 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h5><pre class="line-numbers language-none"><code class="language-none">ifeq 如果等于0，则跳转 ifne 如果不等于0，则跳转 iflt 如果小于0，则跳转 ifge 如果大于等于0，则跳转 ifgt 如果大于0，则跳转 ifle 如果小于等于0，则跳转 if_icmpcq 如果两个int值相等，则跳转 if_icmpne 如果两个int类型值不相等，则跳转 if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转 if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转 if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转 if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转 ifnull 如果等于null，则跳转 ifnonnull 如果不等于null，则跳转 if_acmpeq 如果两个对象引用相等，则跳转 if_acmpnc 如果两个对象引用不相等，则跳转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h5><pre class="line-numbers language-none"><code class="language-none">lcmp 比较long类型值 fcmpl 比较float类型值（当遇到NaN时，返回-1） fcmpg 比较float类型值（当遇到NaN时，返回1） dcmpl 比较double类型值（当遇到NaN时，返回-1） dcmpg 比较double类型值（当遇到NaN时，返回1）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h5><pre class="line-numbers language-none"><code class="language-none">goto 无条件跳转 goto_w 无条件跳转（宽索引）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="表跳转指令"><a href="#表跳转指令" class="headerlink" title="表跳转指令"></a>表跳转指令</h5><pre class="line-numbers language-none"><code class="language-none">tableswitch 通过索引访问跳转表，并跳转 lookupswitch 通过键值匹配访问跳转表，并执行跳转操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><pre class="line-numbers language-none"><code class="language-none">athrow 抛出异常或错误 finally子句 jsr 跳转到子例程 jsr_w 跳转到子例程（宽索引） rct 从子例程返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法调用与返回"><a href="#方法调用与返回" class="headerlink" title="方法调用与返回"></a>方法调用与返回</h4><h5 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h5><pre class="line-numbers language-none"><code class="language-none">invokcvirtual 运行时按照对象的类来调用实例方法 invokespecial 根据编译时类型来调用实例方法 invokestatic 调用类（静态）方法 invokcinterface 调用接口方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h5><pre class="line-numbers language-none"><code class="language-none">ireturn 从方法中返回int类型的数据 lreturn 从方法中返回long类型的数据 freturn 从方法中返回float类型的数据 dreturn 从方法中返回double类型的数据 areturn 从方法中返回引用类型的数据 return 从方法中返回，返回值为void<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><pre class="line-numbers language-none"><code class="language-none">montiorenter 进入并获取对象监视器 monitorexit 释放并退出对象监视器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="JVM指令助记符"><a href="#JVM指令助记符" class="headerlink" title="JVM指令助记符"></a>JVM指令助记符</h4><pre class="line-numbers language-none"><code class="language-none">变量到操作数栈：iload, iload_, lload, lload_, fload, fload_, dload, dload_, aload, aload_ 操作数栈到变量： istore, istore_, lstore, lstore_, fstore, fstore_, dstore,dstor_, astore,astore_ 常数到操作数栈：bipush, sipush, ldc, ldc_w, ldc2_w, aconst_null, iconst_ml, iconst_, lconst_, fconst_, dconst_ 加：iadd, ladd, fadd, dadd 减：isub, lsub, fsub, dsub 乘：imul, lmul, fmul, dmul 除：idiv, ldiv, fdiv, ddiv余数：irem, lrem, frem, drem取负：ineg, lneg, fneg, dneg移位：ishl, lshr, iushr, lshl, lshr, lushr 按位或：ior, lor 按位与：iand, land 按位异或：ixor, lxor 类型转换：i2l, i2f, i2d, l2f, l2d, f2d(放宽数值转换) i2b, i2c, i2s, l2i, f2i, f2l, d2i, d2l, d2f(缩窄数值转换) 创建类实便：new创建新数组：newarray, anewarray, multianwarray访问类的域和类实例域：getfield, putfield, getstatic, putstatic 把数据装载到操作数栈：baload, caload, saload, iaload, laload, faload, daload, aaload 从操作数栈存存储到数组： bastore, castore, sastore, iastore, lastore, fastore, dastore, aastore 获取数组长度：arraylength 检相类实例或数组属性：instanceof, checkcast 操作数栈管理：pop, pop2, dup, dup2, dup_xl, dup2_xl, dup_x2, dup2_x2, swap 有条件转移：ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnonnull, if_icmpeq, if_icmpene, if_icmplt, if_icmpgt, if_icmple, if_icmpge, if_acmpeq, if_acmpne, lcmp, fcmpl fcmpg, dcmpl, dcmpg 复合条件转移：tableswitch, lookupswitch 无条件转移：goto, goto_w, jsr, jsr_w, ret 调度对象的实便方法：invokevirtual 调用由接口实现的方法：invokeinterface 调用需要特殊处理的实例方法：invokespecial 调用命名类中的静态方法：invokestatic 方法返回：ireturn, lreturn, freturn, dreturn, areturn, return异常：athrow finally关键字的实现使用：jsr, jsr_w, ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制</title>
      <link href="/2022/03/21/xingnengdiaoyou01congjdkyuanmajibiechedipouxijvmleijiazaijizhi/"/>
      <url>/2022/03/21/xingnengdiaoyou01congjdkyuanmajibiechedipouxijvmleijiazaijizhi/</url>
      
        <content type="html"><![CDATA[<h4 id="类加载运行全过程"><a href="#类加载运行全过程" class="headerlink" title="类加载运行全过程"></a><strong>类加载运行全过程</strong></h4><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到 JVM。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.learn.jvm.source01;public class Math {    public static final int initData = 666;    public static User user = new User();    public int compute() { //一个方法对应一块栈帧内存区域        int a = 1;        int b = 2;        int c = (a + b) * 10;        return c;    }    public static void main(String[] args) {        Math math = new Math();        math.compute();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通过Java命令执行代码的大体流程如下"><a href="#通过Java命令执行代码的大体流程如下" class="headerlink" title="通过Java命令执行代码的大体流程如下:"></a><strong>通过Java命令执行代码的大体流程如下:</strong></h4><p><img src="http://feng.mynatapp.cc/blog/20220329151014.png"></p><p>其中loadClass的类加载过程有如下几步:</p><p>**加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 **&gt;&gt; 使用 &gt;&gt; 卸载</p><ul><li><p><strong>加载</strong>：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的 main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p></li><li><p><strong>验证</strong>：校验字节码文件的正确性 </p></li><li><p><strong>准备</strong>：给类的静态变量分配内存，并赋予默认值 </p></li><li><p><strong>解析</strong>：将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过 程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用</p></li><li><p><strong>初始化</strong>：对类的静态变量初始化为指定的值，执行静态代码块</p><p><img src="http://feng.mynatapp.cc/blog/20220329152737.png"></p></li></ul><p>类被加载到方法区中后主要包含 <strong>运行时常量池、类型信息、字段信息、方法信息、类加载器的 引用、对应class实例的引用</strong>等信息。</p><p><strong>类加载器的引用</strong>：这个类到类加载器实例的引用 </p><p><strong>对应class实例的引用</strong>：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的 对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</p><p><strong>！注意</strong>，主类在运行过程中如果使用到其它类，会逐步加载这些类。 jar包或war包里的类不是一次性全部加载的，是使用到时才加载。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.learn.jvm.source01;public class TestDynamicLoad {    static {        System.out.println("*************load TestDynamicLoad************");    }    public static void main(String[] args) {        new A();        System.out.println("*************load test************");        B b = null; // B不会加载，除非这里执行 new B()    }}class A {    static {        System.out.println("*************load A************");    }    public A() {        System.out.println("*************initial A************");    }}class B {    static {        System.out.println("*************load B************");    }    public B() {        System.out.println("*************initial B************");    }}运行结果:*************loadTestDynamicLoad*************************loadA*************************initialA*************************loadtest************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类加载器和双亲委派机制</strong></p><p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</p><ul><li>引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等</li><li>扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包</li><li>应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那 些类</li><li>自定义加载器：负责加载用户自定义路径下的类包</li></ul><p>看一个<strong>类加载器</strong>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.learn.jvm.source01;import sun.misc.Launcher;import java.net.URL;public class TestJDKClassLoader {    public static void main(String[] args) {        System.out.println(String.class.getClassLoader());        System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());        System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());        System.out.println();        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();        ClassLoader extClassloader = appClassLoader.getParent();        ClassLoader bootstrapLoader = extClassloader.getParent();        System.out.println("the bootstrapLoader : " + bootstrapLoader);        System.out.println("the extClassloader : " + extClassloader);        System.out.println("the appClassLoader : " + appClassLoader);        System.out.println();        System.out.println("bootstrapLoader加载以下文件:");        URL[] urls = Launcher.getBootstrapClassPath().getURLs();        for (URL url : urls) {            System.out.println(url);        }        System.out.println();        System.out.println("extClassloader加载以下文件:");        String property = System.getProperty("java.ext.dirs");        for (String s : property.split(":")) {            System.out.println(s);        }        System.out.println();        System.out.println("appClassLoader加载以下文件:");        String property1 = System.getProperty("java.class.path");        for (String s : property1.split(":")) {            System.out.println(s);        }    }}运行结果：nullsun.misc.Launcher$ExtClassLoadersun.misc.Launcher$AppClassLoaderthe bootstrapLoader : nullthe extClassloader : sun.misc.Launcher$ExtClassLoader@355da254the appClassLoader : sun.misc.Launcher$AppClassLoader@18b4aac2bootstrapLoader加载以下文件:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/resources.jarfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/rt.jarfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/sunrsasign.jarfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/jsse.jarfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/jce.jarfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/charsets.jarfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/jfr.jarfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/classesextClassloader加载以下文件:/Users/panyangfeng/Library/Java/Extensions/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/Library/Java/Extensions/Network/Library/Java/Extensions/System/Library/Java/Extensions/usr/lib/javaappClassLoader加载以下文件:/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/charsets.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/deploy.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/cldrdata.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/dnsns.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/jaccess.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/jfxrt.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/localedata.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/nashorn.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/sunec.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/ext/zipfs.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/javaws.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/jce.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/jfr.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/jfxswt.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/jsse.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/management-agent.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/plugin.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/resources.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/jre/lib/rt.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/lib/ant-javafx.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/lib/dt.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/lib/javafx-mx.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/lib/jconsole.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/lib/packager.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/lib/sa-jdi.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home/lib/tools.jar/Users/panyangfeng/Documents/study-source/tuling架构/source-code/jvm-learn/out/production/jvm-learn/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类加载器初始化过程:</strong></p><p>参见类运行加载全过程图可知其中会创建JVM启动器实例sun.misc.Launcher。 sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个 sun.misc.Launcher实例。</p><p>在Launcher构造方法内部，其创建了两个类加载器，分别是 sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应 用类加载器)。 </p><p>JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// Launcher的构造方法public Launcher() {        Launcher.ExtClassLoader var1;        try {            var1 = Launcher.ExtClassLoader.getExtClassLoader();        } catch (IOException var10) {            throw new InternalError("Could not create extension class loader", var10);        }        try {            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);        } catch (IOException var9) {            throw new InternalError("Could not create application class loader", var9);        }        Thread.currentThread().setContextClassLoader(this.loader);        String var2 = System.getProperty("java.security.manager");        if (var2 != null) {            SecurityManager var3 = null;            if (!"".equals(var2) &amp;&amp; !"default".equals(var2)) {                try {                    var3 = (SecurityManager)this.loader.loadClass(var2).newInstance();                } catch (IllegalAccessException var5) {                } catch (InstantiationException var6) {                } catch (ClassNotFoundException var7) {                } catch (ClassCastException var8) {                }            } else {                var3 = new SecurityManager();            }            if (var3 == null) {                throw new InternalError("Could not create SecurityManager: " + var2);            }            System.setSecurityManager(var3);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双亲委派机制</strong></p><p> JVM类加载器是有亲子层级结构的，如下图</p><img src="http://feng.mynatapp.cc/blog/20220329153318.png" style="zoom:50%;"><p>这里类加载其实就有一个<strong>双亲委派机制</strong>，加载某个类时会先委托父加载器寻找目标类，找不到再 委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。</p><p>比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载 器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天 没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的 类加载路径里找了半天也没找到Math类，又向下退回Math类的加载请求给应用程序类加载器， 应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了。。</p><p><strong>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</strong></p><p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader 的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下:</p><ol><li><p>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。</p></li><li><p>如果此类没有加载过，那么，再判断一下是否有父加载器;如果有父加载器，则由父加 载器加载(即调用parent.loadClass(name, false);).或者是调用bootstrap类加载器来加 载。</p></li><li><p>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass方法来完成类加载。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">// ClassLoader的loadClass方法，里面实现了双亲委派机制protected Class&lt;?&gt; loadClass(String name, boolean resolve)        throws ClassNotFoundException    {        synchronized (getClassLoadingLock(name)) {            // First, check if the class has already been loaded          // 检查当前类加载器是否已经加载了该类            Class&lt;?&gt; c = findLoadedClass(name);            if (c == null) {                long t0 = System.nanoTime();                try {                    if (parent != null) { //如果当前加载器父加载器不为空则委托父加载器加载该类                        c = parent.loadClass(name, false);                    } else { //如果当前加载器父加载器为空则委托引导类加载器加载该类                        c = findBootstrapClassOrNull(name);                    }                } catch (ClassNotFoundException e) {                    // ClassNotFoundException thrown if class not found                    // from the non-null parent class loader                }                if (c == null) {                    // If still not found, then invoke findClass in order                    // to find the class.                    long t1 = System.nanoTime();                  // 都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类                    c = findClass(name);                    // this is the defining class loader; record the stats                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    sun.misc.PerfCounter.getFindClasses().increment();                }            }            if (resolve) { // 不会执行                resolveClass(c);            }            return c;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>为什么要设计双亲委派机制?</strong> </p><ul><li>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改 </li><li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证<strong>被加载类的唯一性</strong></li></ul><p>看一个类加载示例:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package java.lang;public class String {  public static void main(String[] args) {     System.out.println("**************My String Class**************");  }}运行结果:错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args)否则 JavaFX 应用程序类必须扩展javafx.application.Application<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>全盘负责委托机制</strong></p><p>**”全盘负责”**是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入。</p><p><strong>自定义类加载器示例：</strong></p><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass(String, boolean)，实现了<strong>双亲委派机制</strong>，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是<strong>重写</strong>findClass<strong>方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.learn.jvm.source01;import java.io.FileInputStream;import java.lang.reflect.Method;public class MyClassLoaderTest01 {    static class MyClassLoader extends ClassLoader {        private final String classPath;        public MyClassLoader(String classPath) {            this.classPath = classPath;        }        private byte[] loadByte(String name) throws Exception {            name = name.replaceAll("\\.", "/");            FileInputStream fis = new FileInputStream(classPath + "/" + name + ".class");            int len = fis.available();            byte[] data = new byte[len];            fis.read(data);            fis.close();            return data;        }        @Override        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {            try {                byte[] data = loadByte(name);                // defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。                return defineClass(name, data, 0, data.length);            } catch (Exception e) {                e.printStackTrace();                throw new ClassNotFoundException();            }        }    }    public static void main(String args[]) throws Exception {        // 初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader        // 创建 test/com/learn/jvm/source01 几级目录，将User类的复制类User1.class丢入该目录        MyClassLoader classLoader = new MyClassLoader("/Users/panyangfeng/test");        Class&lt;?&gt; clazz = classLoader.loadClass("com.learn.jvm.source01.User1");        Object obj = clazz.newInstance();        Method method = clazz.getDeclaredMethod("sout", null);        method.invoke(obj, null);        System.out.println(clazz.getClassLoader().getClass().getName());    }}运行结果： =======自己的加载器加载类调用方法======= com.learn.jvm.source01.MyClassLoaderTest01$MyClassLoader<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打破双亲委派机制</strong></p><p>再来一个沙箱安全机制示例，尝试打破双亲委派机制，用自定义类加载器加载我们自己实现java.lang.String.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.learn.jvm.source01;import java.io.FileInputStream;import java.lang.reflect.Method;public class MyClassLoaderTest02 {    static class MyClassLoader extends ClassLoader {        private String classPath;        public MyClassLoader(String classPath) {            this.classPath = classPath;        }        private byte[] loadByte(String name) throws Exception {            name = name.replaceAll("\\.", "/");            FileInputStream fis = new FileInputStream(classPath + "/" + name + ".class");            int len = fis.available();            byte[] data = new byte[len];            fis.read(data);            fis.close();            return data;        }        @Override        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {            try {                byte[] data = loadByte(name);                return defineClass(name, data, 0, data.length);            } catch (Exception e) {                e.printStackTrace();                throw new ClassNotFoundException();            }        }        /**         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载         *         * @param name         * @param resolve         * @return         * @throws ClassNotFoundException         */        @Override        protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {            synchronized (getClassLoadingLock(name)) {                // First, check if the class has already been loaded                Class&lt;?&gt; c = findLoadedClass(name);                if (c == null) {                    // If still not found, then invoke findClass in order                    // to find the class.                    long t1 = System.nanoTime();                    c = findClass(name);                    // this is the defining class loader; record the stats                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    sun.misc.PerfCounter.getFindClasses().increment();                }                if (resolve) {                    resolveClass(c);                }                return c;            }        }    }    public static void main(String args[]) throws Exception {        // 尝试用自己改写类加载机制去加载自己写的java.lang.String.class 65        MyClassLoader classLoader = new MyClassLoader("/Users/panyangfeng/test");        Class&lt;?&gt; clazz = classLoader.loadClass("java.lang.String");        Object obj = clazz.newInstance();        Method method = clazz.getDeclaredMethod("sout", null);        method.invoke(obj, null);        System.out.println(clazz.getClassLoader().getClass().getName());    }}运行结果：java.lang.SecurityException: Prohibited package name: java.langat java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)at java.lang.ClassLoader.defineClass(ClassLoader.java:761)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tomcat打破双亲委派机制</strong></p><p>以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？ 我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p><ol><li><p>一个web容器可能需要部署两个应用程序，不同的应用程序可能会<strong>依赖同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是 独立的，保证相互隔离。</p></li><li><p>部署在同一个web容器中<strong>相同的类库相同的版本可以共享</strong>。否则，如果服务器有10个应用程 序，那么要有10份相同的类库加载进虚拟机。</p></li><li><p><strong>web容器也有自己依赖的类库，不能与应用程序的类库混淆</strong>。基于安全考虑，应该让容器的 类库和程序的类库隔离开来。</p></li><li><p>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中 运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</p></li></ol><p>再看看我们的问题：<strong>Tomcat 如果使用默认的双亲委派类加载机制行不行？</strong></p><p>答案是不行的。为什么？ </p><p>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认 的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。 </p><p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。 </p><p>第三个问题和第一个问题一样。 </p><p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文 件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp 是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想 到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载 器。重新创建类加载器，重新加载jsp文件。</p><p><strong>Tomcat自定义加载器详解</strong></p><p><img src="http://feng.mynatapp.cc/blog/20220329153415.png"></p><p>tomcat的几个主要类加载器：</p><ul><li><p>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容 器本身以及各个Webapp访问；</p></li><li><p>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不 可见；</p></li><li><p>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有 Webapp可见，但是对于Tomcat容器不可见；</p></li><li><p>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前 Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的 WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本， 这样实现就能加载各自的spring版本；</p></li></ul><p>从图中的委派关系中可以看出：</p><p> CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用， 从而实现了公有类库的共用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则 与对方相互隔离。 </p><p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader 实例之间相互隔离。</p><p> 而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的 就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例， 并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。</p><p>tomcat 这种类加载机制违背了java 推荐的双亲委派模型了吗？答案是：违背了。 很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，<strong>每个 webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双亲委派机制</strong>。</p><p><strong>模拟实现Tomcat的webappClassLoader加载自己war包应用内不同版本类实现相互共存与隔离</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.learn.jvm.source01;import java.io.FileInputStream;import java.lang.reflect.Method;public class MyClassLoaderTest03 {    static class MyClassLoader extends ClassLoader {        private String classPath;        public MyClassLoader(String classPath) {            this.classPath = classPath;        }        private byte[] loadByte(String name) throws Exception {            name = name.replaceAll("\\.", "/");            FileInputStream fis = new FileInputStream(classPath + "/" + name + ".class");            int len = fis.available();            byte[] data = new byte[len];            fis.read(data);            fis.close();            return data;        }        @Override        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {            try {                byte[] data = loadByte(name);                return defineClass(name, data, 0, data.length);            } catch (Exception e) {                e.printStackTrace();                throw new ClassNotFoundException();            }        }        /**         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载         *         * @param name         * @param resolve         * @return         * @throws ClassNotFoundException         */        @Override        protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {            synchronized (getClassLoadingLock(name)) {                // First, check if the class has already been loaded                Class&lt;?&gt; c = findLoadedClass(name);                if (c == null) {                    // If still not found, then invoke findClass in order                    // to find the class.                    long t1 = System.nanoTime();                    //非自定义的类还是走双亲委派加载                    if (!name.startsWith("com.learn.jvm")) {                        c = this.getParent().loadClass(name);                    } else {                        c = findClass(name);                    }                    // this is the defining class loader; record the stats                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    sun.misc.PerfCounter.getFindClasses().increment();                }                if (resolve) {                    resolveClass(c);                }                return c;            }        }    }    public static void main(String args[]) throws Exception {        MyClassLoader classLoader = new MyClassLoader("/Users/panyangfeng/test");        Class&lt;?&gt; clazz = classLoader.loadClass("com.learn.jvm.source01.User1");        Object obj = clazz.newInstance();        Method method = clazz.getDeclaredMethod("sout", null);        method.invoke(obj, null);        System.out.println(clazz.getClassLoader());        System.out.println();        MyClassLoader classLoader1 = new MyClassLoader("/Users/panyangfeng/test1");        Class&lt;?&gt; clazz1 = classLoader1.loadClass("com.learn.jvm.source01.User1");        Object obj1 = clazz1.newInstance();        Method method1 = clazz1.getDeclaredMethod("sout", null);        method1.invoke(obj1, null);        System.out.println(clazz1.getClassLoader());    }}运行结果：=======自己的加载器加载类调用方法======= com.learn.jvm.source01.MyClassLoaderTest03$MyClassLoader@610455d6=======另外一个User1版本：自己的加载器加载类调用方法======= com.learn.jvm.source01.MyClassLoaderTest03$MyClassLoader@5e2de80c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="color:red;">注意：</span>同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一 样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类 加载器也是同一个才能认为他们是同一个。</p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK源码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
